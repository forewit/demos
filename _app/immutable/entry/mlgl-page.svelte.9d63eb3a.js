import{S as w,i as z,s as C,k as b,a as B,q as S,l as h,m as _,c as U,r as v,h as P,n as y,b as R,E as i,L as T,I as G}from"../chunks/index.fce9d48b.js";//! --------- exports -------------
let q={compute:x};async function x(g,t,...n){if(!navigator.gpu)throw Error("WebGPU not supported.");const o=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!o)throw Error("Couldn't request WebGPU adapter.");o.isFallbackAdapter&&console.warn("WebGPU is using a fallback adapter!");const a=await o.requestDevice(),s=a.createShaderModule({code:g}),u=a.createComputePipeline({layout:"auto",compute:{module:s,entryPoint:"main"}}),d=n.map(e=>({binding:e.binding,GPUBuffer:a.createBuffer({usage:e.usage,size:e.byteSize}),data:e.data}));for(const e of d)e.data&&a.queue.writeBuffer(e.GPUBuffer,0,e.data,0,e.data.length);const p=d.filter(e=>!e.data).map(e=>({binding:e.binding,source:e.GPUBuffer,destination:a.createBuffer({usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST,size:e.GPUBuffer.size})})),f=a.createBindGroup({layout:u.getBindGroupLayout(0),entries:d.map(e=>({binding:e.binding,resource:{buffer:e.GPUBuffer}}))}),l=a.createCommandEncoder(),c=l.beginComputePass();c.setPipeline(u),c.setBindGroup(0,f),c.dispatchWorkgroups(t),c.end();for(const e of p)l.copyBufferToBuffer(e.source,0,e.destination,0,e.destination.size);a.queue.submit([l.finish()]);let m={};for(const e of p){await e.destination.mapAsync(GPUMapMode.READ,0,e.destination.size);const r=e.destination.getMappedRange(0,e.destination.size);m[e.binding]=new Float32Array(r.slice(0)),e.destination.unmap()}return m}function L(g){let t,n,o,a,s,u,d,p,f,l,c,m;return{c(){t=b("form"),n=b("input"),o=B(),a=b("label"),s=S("Enable option one"),u=B(),d=b("br"),p=B(),f=b("button"),l=S("Run"),this.h()},l(e){t=h(e,"FORM",{id:!0});var r=_(t);n=h(r,"INPUT",{type:!0,id:!0}),o=U(r),a=h(r,"LABEL",{for:!0});var E=_(a);s=v(E,"Enable option one"),E.forEach(P),u=U(r),d=h(r,"BR",{}),p=U(r),f=h(r,"BUTTON",{type:!0});var A=_(f);l=v(A,"Run"),A.forEach(P),r.forEach(P),this.h()},h(){y(n,"type","checkbox"),y(n,"id","option_1"),y(a,"for","option_1"),y(f,"type","submit"),y(t,"id","form")},m(e,r){R(e,t,r),i(t,n),i(t,o),i(t,a),i(a,s),i(t,u),i(t,d),i(t,p),i(t,f),i(f,l),c||(m=T(t,"submit",g[0]),c=!0)},p:G,i:G,o:G,d(e){e&&P(t),c=!1,m()}}}function M(g){async function t(){let n=new Float32Array(Array.from({length:32},(s,u)=>u));const o=2,a=`
@group(0) @binding(0) var<storage> input: array<f32>;
@group(0) @binding(1) var<storage, read_write> output: array<f32>;

@compute @workgroup_size(${n.byteLength/o})
fn main(@builtin(local_invocation_id) local_id : vec3<u32>) {

  output[local_id.x] = input[local_id.x];
}`;q.compute(a,o,{binding:0,byteSize:n.byteLength,data:n,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST},{binding:1,byteSize:n.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}).then(s=>{console.log(s)})}return[t]}class k extends w{constructor(t){super(),z(this,t,M,L,C,{})}}export{k as default};
