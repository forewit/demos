import{S as x,i as A,s as S,k as m,a as w,q as z,l as b,m as P,c as B,r as E,h,n as y,b as R,E as u,L as C,I as v,o as q}from"../chunks/index.fce9d48b.js";//! --------- exports -------------
let M={compute:T};//! -------------------------------
async function T(g,t,...a){if(!navigator.gpu)throw Error("WebGPU not supported.");const i=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!i)throw Error("Couldn't request WebGPU adapter.");i.isFallbackAdapter&&console.warn("WebGPU is using a fallback adapter!");const o=await i.requestDevice(),d=o.createShaderModule({code:g}),n=o.createComputePipeline({layout:"auto",compute:{module:d,entryPoint:"main"}}),s=a.map(e=>({binding:e.id,GPUBuffer:o.createBuffer({usage:e.usage,size:e.byteSize}),data:e.data}));for(const e of s)e.data&&o.queue.writeBuffer(e.GPUBuffer,0,e.data,0,e.data.length);const p=s.filter(e=>!e.data).map(e=>({binding:e.binding,source:e.GPUBuffer,destination:o.createBuffer({usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST,size:e.GPUBuffer.size})})),l=o.createBindGroup({layout:n.getBindGroupLayout(0),entries:s.map(e=>({binding:e.binding,resource:{buffer:e.GPUBuffer}}))}),f=o.createCommandEncoder(),c=f.beginComputePass();c.setPipeline(n),c.setBindGroup(0,l),c.dispatchWorkgroups(t),c.end();for(const e of p)f.copyBufferToBuffer(e.source,0,e.destination,0,e.destination.size);o.queue.submit([f.finish()]);let _={};for(const e of p){await e.destination.mapAsync(GPUMapMode.READ,0,e.destination.size);const r=e.destination.getMappedRange(0,e.destination.size);_[e.binding]=new Float32Array(r.slice(0)),e.destination.unmap()}return _}let U={layer_size:3,layer_count:3,layers:Float32Array.from([0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0])};`${U.layers.length}${U.layer_size}${U.layer_count}`;function O(g){let t,a,i,o,d,n,s,p,l,f,c,_;return{c(){t=m("form"),a=m("input"),i=w(),o=m("label"),d=z("Enable option one"),n=w(),s=m("br"),p=w(),l=m("button"),f=z("Run"),this.h()},l(e){t=b(e,"FORM",{id:!0});var r=P(t);a=b(r,"INPUT",{type:!0,id:!0}),i=B(r),o=b(r,"LABEL",{for:!0});var k=P(o);d=E(k,"Enable option one"),k.forEach(h),n=B(r),s=b(r,"BR",{}),p=B(r),l=b(r,"BUTTON",{type:!0});var G=P(l);f=E(G,"Run"),G.forEach(h),r.forEach(h),this.h()},h(){y(a,"type","checkbox"),y(a,"id","option_1"),y(o,"for","option_1"),y(l,"type","submit"),y(t,"id","form")},m(e,r){R(e,t,r),u(t,a),u(t,i),u(t,o),u(o,d),u(t,n),u(t,s),u(t,p),u(t,l),u(l,f),c||(_=C(t,"submit",g[0]),c=!0)},p:v,i:v,o:v,d(e){e&&h(t),c=!1,_()}}}function L(g){async function t(){let a=new Float32Array(Array.from({length:32},(n,s)=>s));const i=8,o=4,d=`
@group(0) @binding(0) var<storage> input: array<f32>;
@group(0) @binding(1) var<storage, read_write> output: array<f32>;

@compute @workgroup_size(${i})
fn main(
  @builtin(local_invocation_id) local_id : vec3<u32>, 
  @builtin(global_invocation_id) global_id : vec3<u32>,
  @builtin(workgroup_id) workgroup_id : vec3<u32>
) {
  output[global_id.x] = f32(global_id.x)*1000 + f32(local_id.x) + 0*input[0];
  //output[global_id.x] = f32(workgroup_id.x);
}`;M.compute(d,o,{id:0,byteSize:a.byteLength,data:a,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST},{id:1,byteSize:a.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}).then(n=>{console.log(n[1])})}return q(()=>{t()}),[t]}class D extends x{constructor(t){super(),A(this,t,L,O,S,{})}}export{D as default};
